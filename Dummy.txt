--은행테이블
DROP TABLE tbl_bank;
CREATE TABLE tbl_bank(
  bno NUMBER PRIMARY KEY,
  bname VARCHAR2(50) NOT NULL,
  pw VARCHAR2(50) NOT NULL,
  money NUMBER DEFAULT 0,
  regdate DATE DEFAULT SYSDATE
);

DROP SEQUENCE seq_bank;
CREATE SEQUENCE seq_bank
    START WITH 101
    INCREMENT BY 1
    NOCYCLE;
    
INSERT INTO tbl_bank(bno,bname,pw)
VALUES(seq_bank.NEXTVAL,'김행화','1234');
INSERT INTO tbl_bank(bno,bname,pw)
VALUES(seq_bank.NEXTVAL,'정우영','4567');
INSERT INTO tbl_bank(bno,bname,pw)
VALUES(seq_bank.NEXTVAL,'김예슬','7890');
INSERT INTO tbl_bank(bno,bname,pw)
VALUES(seq_bank.NEXTVAL,'나솔애','1111');
INSERT INTO tbl_bank(bno,bname,pw)
VALUES(seq_bank.NEXTVAL,'양시윤','2222');

COMMIT;
SELECT * FROM tbl_bank;

-- 게시판 테이블
DROP TABLE tbl_board;
CREATE TABLE tbl_board(
    bno NUMBER PRIMARY KEY,  
    title VARCHAR2(200) NOT NULL,
    content VARCHAR2(500) NOT NULL,
    writer VARCHAR2(100) NOT NULL,
    viewcnt NUMBER DEFAULT 0, -- 최초 게시글 등록시 조회수 0부터 시작
    regdate DATE DEFAULT SYSDATE
);
CREATE SEQUENCE seq_board
    START WITH 1
    INCREMENT BY 1
    NOCYCLE;
    

SELECT * FROM tbl_board;

--1. 등록
INSERT INTO tbl_board(bno,title,content,writer)
VALUES(seq_board.NEXTVAL,'본보야지 4 봄?','너무 귀여워','아미1');
INSERT INTO tbl_board(bno,title,content,writer)
VALUES(seq_board.NEXTVAL,'태형아','생일축하해','윈터베어');
INSERT INTO tbl_board(bno,title,content,writer)
VALUES(seq_board.NEXTVAL,'구오즈 우정목걸리','어느 브랜드꺼인가요','구오즈만세');
INSERT INTO tbl_board(bno,title,content,writer)
VALUES(seq_board.NEXTVAL,'2020윈터패키지','역대급화보임','스프링패키지원함');
INSERT INTO tbl_board(bno,title,content,writer)
VALUES(seq_board.NEXTVAL,'내년 한콘하냐','빅힛 제발 일해라','아미총연합');



-- 2.수정
UPDATE tbl_board
    SET title = '본보 시즌4',
        content = '미치도록 귀엽다',
        writer = '월드스타BTS'
WHERE bno = 1;    

COMMIT;
SELECT * FROM tbl_board;

--3.삭제
DELETE tbl_board
WHERE bno = 5;

SELECT * FROM tbl_board;

ROLLBACK;

--4.전체조회
SELECT * FROM tbl_board;


--5. title과 content에서 '윈'글자 검색
SELECT * FROM tbl_board
WHERE title LIKE '%윈%' OR
content  LIKE '%윈%';

--6.오름차순 정렬
SELECT * FROM tbl_board
ORDER BY viewcnt DESC;

--7.게시물 번호로 조회( 상세게시글)
SELECT * FROM  tbl_board
WHERE bno = 1;

--조회수 증가
UPDATE tbl_board
    SET viewcnt = viewcnt + 1
WHERE bno = 1;    

--멤버 테이블
CREATE TABLE tbl_member(
    id VARCHAR2(50) PRIMARY KEY,
    pw VARCHAR2(100) NOT NULL,
    name VARCHAR2(100) NOT NULL,
    phone VARCHAR2(100) NOT NULL,
    regdate DATE DEFAULT SYSDATE
);

INSERT INTO tbl_member(id,pw,name,phone)
VALUES('LoveRM','0912','김남준','010-2018-1022');
INSERT INTO tbl_member(id,pw,name,phone)
VALUES('eatjin','1204','김석진','010-2019-0605');
INSERT INTO tbl_member(id,pw,name,phone)
VALUES('AgustD','0309','민윤기','010-2016-0815');
INSERT INTO tbl_member(id,pw,name,phone)
VALUES('hopeworld','0218','정호석','010-2018-0301');
INSERT INTO tbl_member(id,pw,name,phone)
VALUES('fairyJ','1013','박지민','010-2013-0618');
INSERT INTO tbl_member(id,pw,name,phone)
VALUES('winterbear','1230','김태형','010-2018-0809');
INSERT INTO tbl_member(id,pw,name,phone)
VALUES('goldbaby','0901','전정국','010-2013-0613');

COMMIT;

-- 수정
UPDATE tbl_member
    SET id = 'RainRM'
WHERE name = '김남준';    

UPDATE tbl_member
    SET phone = '010-2019-0809'
WHERE name = '김태형';    

-- 로그인 할 떄 아이디와 비밀번호가 맞는 것을 찾음
SELECT * FROM tbl_member
WHERE id = 'RainRM' AND pw = '0912';

--로그인 유무만 알려고 함, 값을 전달 받으려는 것이 아니기 때문에 COUNT 사용
SELECT COUNT(*) FROM tbl_member
WHERE id = 'hopeworld' AND pw = '0218';

SELECT writer FROM tbl_board
WHERE bno = 2;

SELECT * FROM tbl_member;

-- 편의점테이블
DROP TABLE tbl_product;
CREATE TABLE tbl_product(
    pno NUMBER PRIMARY KEY,
    pname VARCHAR2(100) NOT NULL,
    company VARCHAR2(100) NOT NULL,
    price NUMBER DEFAULT 0,
    cnt NUMBER DEFAULT 0,
    regdate DATE DEFAULT  SYSDATE
);

DROP SEQUENCE seq_product;
CREATE SEQUENCE seq_product
    START WITH 1001
    INCREMENT BY 1
    NOCYCLE;
    
    
SELECT * FROM tbl_product;

--2.제품등록
INSERT INTO tbl_product(pno,pname,company,price,cnt)
VALUES(seq_product.NEXTVAL,'에이스초콜라또',해태,4800,30);
INSERT INTO tbl_product(pno,pname,company,price,cnt)
VALUES(seq_product.NEXTVAL,'마가렛트','롯데',4000,11);
INSERT INTO tbl_product(pno,pname,company,price,cnt)
VALUES(seq_product.NEXTVAL,'스프라이트','코카콜라',1500,20);
INSERT INTO tbl_product(pno,pname,company,price,cnt)
VALUES(seq_product.NEXTVAL,'팔도비빔면','팔도',3500,35);

COMMIT;

--3.제품수정
UPDATE tbl_product
    SET company = 'paldo',
        price = 4000,
        cnt = 40
WHERE pname = '팔도비빔면'

COMMIT;
SELECT * FROM tbl_product;

--4. 제품삭제
DELETE tbl_product
WHERE pname= '마가렛트';

--5. 제품조회
SELECT * FROM tbl_product;

--6. 제품검색
SELECT * FROM tbl_product
WHERE pname LIKE '%마%';

SELECT COUNT(*) FROM tbl_product
WHERE pname LIKE '%오%';

SELECT COUNT(*) FROM tbl_product
WHERE pname LIKE '%마%';



-- 매출 테이블 
DROP TABLE tbl_sale;
CREATE TABLE tbl_sale(
    sno NUMBER PRIMARY KEY,
    sname VARCHAR2(100) NOT NULL,
    cnt NUMBER NOT NULL,
    tprice NUMBER NOT NULL,
    regdate DATE DEFAULT SYSDATE
);

CREATE SEQUENCE seq_sale
    START WITH 1001
    INCREMENT BY 1
    NOCYCLE;




DELETE tbl_sale
WHERE sno = 1001;

--매출
INSERT INTO tbl_sale(sno,sname,cnt,tprice)
VALUES(SEQ_SALE.nextval,'팔도비빔면',3,3800*3);

DELETE tbl_sale
WHERE sno = 1002;

COMMIT;

SELECT * FROM tbl_sale;

-- 전체 총 판매액
SELECT SUM(tprice) FROM tbl_sale;

-- 제품별 총 판매액
SELECT sname,SUM(tprice) 
FROM tbl_sale
GROUP BY sname;

--To_CHAR : 문자열로 형변환시켜주는 것 
--regdate

--일일 판매한 제품의  총 판매액
SELECT SUM(tprice) FROM tbl_sale
WHERE TO_CHAR(regdate,'YYYYMMDD') = TO_CHAR(SYSDATE,'YYYYMMDD');



--오늘 판매한 상품의 수량과 총 금액
SELECT sname,SUM(cnt),SUM(tprice) 
FROM tbl_sale
WHERE TO_CHAR(regdate,'YYYYMMDD') = TO_CHAR(SYSDATE,'YYYYMMDD')
GROUP BY sname;



DROP TABLE EMP;
DROP TABLE DEPT;
DROP TABLE BONUS;
DROP TABLE SALGRADE;
DROP TABLE DUMMY;
 
CREATE TABLE EMP
       (EMPNO NUMBER(4) PRIMARY KEY,
        ENAME VARCHAR2(10),
        JOB VARCHAR2(9),
        MGR NUMBER(4),
        HIREDATE DATE,
        SAL NUMBER(7, 2),
        COMM NUMBER(7, 2),
        DEPTNO NUMBER(2));
 
INSERT INTO EMP VALUES
        (7369, 'SMITH',  'CLERK',     7902,
        sysdate,  800, NULL, 20);
         
INSERT INTO EMP VALUES
        (7499, 'ALLEN',  'SALESMAN',  7698,
        sysdate, 1600,  300, 30);
         
INSERT INTO EMP VALUES
        (7521, 'WARD',   'SALESMAN',  7698,
        sysdate, 1250,  500, 30);
         
INSERT INTO EMP VALUES
        (7566, 'JONES',  'MANAGER',   7839,
        sysdate,  2975, NULL, 20);
         
INSERT INTO EMP VALUES
        (7654, 'MARTIN', 'SALESMAN',  7698,
        sysdate, 1250, 1400, 30);
         
INSERT INTO EMP VALUES
        (7698, 'BLAKE',  'MANAGER',   7839,
        sysdate,  2850, NULL, 30);
         
INSERT INTO EMP VALUES
        (7782, 'CLARK',  'MANAGER',   7839,
        sysdate,  2450, NULL, 10);
INSERT INTO EMP VALUES
        (7788, 'SCOTT',  'ANALYST',   7566,
        sysdate, 3000, NULL, 20);
         
INSERT INTO EMP VALUES
        (7839, 'KING',   'PRESIDENT', NULL,
        sysdate, 5000, NULL, 10);
         
INSERT INTO EMP VALUES
        (7844, 'TURNER', 'SALESMAN',  7698,
        sysdate,  1500,    0, 30);
         
INSERT INTO EMP VALUES
        (7876, 'ADAMS',  'CLERK',     7788,
        sysdate, 1100, NULL, 20);
         
INSERT INTO EMP VALUES
        (7900, 'JAMES',  'CLERK',     7698,
        sysdate,   950, NULL, 30);
         
INSERT INTO EMP VALUES
        (7902, 'FORD',   'ANALYST',   7566,
        sysdate,  3000, NULL, 20);
         
INSERT INTO EMP VALUES
        (7934, 'MILLER', 'CLERK',     7782,
        sysdate, 1300, NULL, 10);
 
CREATE TABLE DEPT
       (DEPTNO NUMBER(2) PRIMARY KEY,
        DNAME VARCHAR2(14),
        LOC VARCHAR2(13) );
 
INSERT INTO DEPT VALUES (10, 'ACCOUNTING', 'NEW YORK');
INSERT INTO DEPT VALUES (20, 'RESEARCH',   'DALLAS');
INSERT INTO DEPT VALUES (30, 'SALES',      'CHICAGO');
INSERT INTO DEPT VALUES (40, 'OPERATIONS', 'BOSTON');
 
CREATE TABLE BONUS
        (ENAME VARCHAR2(10),
         JOB   VARCHAR2(9),
         SAL   NUMBER,
         COMM  NUMBER);
 
CREATE TABLE SALGRADE
        (GRADE NUMBER,
         LOSAL NUMBER,
         HISAL NUMBER);
 
INSERT INTO SALGRADE VALUES (1,  700, 1200);
INSERT INTO SALGRADE VALUES (2, 1201, 1400);
INSERT INTO SALGRADE VALUES (3, 1401, 2000);
INSERT INTO SALGRADE VALUES (4, 2001, 3000);
INSERT INTO SALGRADE VALUES (5, 3001, 9999);
 
CREATE TABLE DUMMY
        (DUMMY NUMBER);
 
INSERT INTO DUMMY VALUES (0);
 
COMMIT;

SELECT * FROM emp;

--Join 

--사원내용
SELECT * FROM emp; -- detpno : FK키
--부서내용
SELECT * FROM dept; -- detpno:PK키

SELECT *
FROM dept, emp
WHERE dept.deptno = emp.deptno;

SELECT *
FROM dept, emp
WHERE dept.deptno = emp.deptno;


--JOIN 종류
--1.Equi Join(동등조인)
-- 양쪽 테이블에 값이 있어야 작동, 한곳에라도 값이 없으면 결과가 나오지 않음
-- ex) dept테이블과 emp 테이블을 조인

SELECT emp.empno, emp.ename as 사원이름, dept.dname
FROM dept, emp 
WHERE dept.deptno = emp.deptno;

--ALIAS
SELECT e.empno, e.ename as 사원이름, d.dname
FROM dept d, emp e
WHERE d.deptno = e.deptno;

--2.Inner Join == Equi Join
--ex) dept테이블과 emp 테이블을 Inner조인
-- , 대신에 Inner Join을 사용 (Inner 생략 가능)
-- WHERE절이 ON절 → JOIN의 조건
SELECT e.empno, e.ename, d.dname
FROM dept d
INNER JOIN emp e
ON d.deptno = e.deptno;

-- 3. Natural Join == Equi Join 
--ex) dept테이블과 emp 테이블을 Natural조인
-- 동일한 컬럼을 내부적으로 모두 조인, ON절(동등조건)이 생략가능
SELECT e.empno , e.ename , d.dname
FROM dept d
NATURAL JOIN emp e;
--Using(deptno); 동일한 이름을 가지는 컬럼은 모두 조인 됨으로 Using을 사용하면 컬럼을 선택해서 조인 가능

--4. Non-Equi Join
-- 테이블의 어떤 컬럼도 Join 할 테이블의 컬럼과 일치하지 않을 때
-- 조인조건은 동등(=) 이외의 연산자를 사용합니다
-- BETWEEN AND, IS NULL, IS NOT NULL,IN,NOT IN
-- 거의 사용하지않는다 

--연봉 등급: 등급별 연봉최저액 ~ 최고액
SELECT * FROM salgrade; 
--ex) emp테이블과 salgrade테이블의 Non-Equi Join
SELECT e.ename, e.sal, s.grade
FROM emp e, salgrade s
WHERE e.sal
BETWEEN s.losal
AND s.hisal;

--5. Self Join
-- Equi Join과 같으나 하나의 테이블에서 조인이 일어난다는 것이 다르다
-- 같은 테이블에 대해 두개의 alias를 사용하여, FROM 절에 두개의 테이블 사용하는 것처럼 조인한다.
-- ex)사원의 매니저이름을 조회하는 Self Join
SELECT e.ename, a.ename as Manager
FROM emp e, emp a
WHERE e.empno = a.mgr;
SELECT * FROM emp;

-- ※.Cartesian Product
-- 컬럼을 곱해서 모든 경우의 수를 띄워주는 것
-- 검색하고자했던 데이터뿐 아니라 조인에 사용된 테이블들의 모든 데이터가 반환되는 현상
-- Cartesian Product 는 조인 조건을 정의하지 않은 경우 발생
-- CROSS JOIN을 사용하면 Cartesian Product 값을 얻을 수 있음
-- ex) CROSS JOIN 절을 이용하여 Cartesian Product 값을 얻는 예제
SELECT e.empno, e.ename, d.dname
FROM dept d CROSS JOIN emp e;
-- emp 14개 dept 14개 → 14 x 4 = 56건 출력

--7. Outer Join
--한쪽에 값이 없더라도 값이 나오게 해주는 것
--Equi Join은 조인을 생성하려는 두 개의 테이블의 한쪽 컬럼에서 값이 없다면 데이터를 반환하지 못함
--동일 조건에서 조인 조건을 만조갛는 값이 없는 행등르 조회하기 위해 Outer Join 을 사용
--Outer Join 연산자는 (+)이다
--조인시 값이 없는 조인측에 (+)를 위치 시킨다
--Outer Join 연산자는 표현식의 한편에만 올 수 있다.
--ex) Equi Join과 Outer Join의 비교
-- ex1) Equi Join으로 부서번호를 조회
SELECT DISTINCT(e.deptno), d.deptno, d.dname
FROM emp e, dept d
WHERE e.deptno = d.deptno;
 
--ex)  Outer Join으로 부서번호를 조회
-- e.deptno(+) : emp의 deptno테이블에서 값이 없어도 출력해주세요
SELECT DISTINCT(e.deptno), d.deptno, d.dname
FROM emp e,dept d
WHERE e.deptno(+) = d.deptno;

--ex3) LEFT OUTER JOIN (left에 값이 다 있는것)
SELECT DISTINCT(e.deptno), d.deptno, d.dname
FROM dept d
LEFT OUTER JOIN emp e
ON d.deptno = e.deptno;

--ex4) LIGHT OUTER JOIN(right쪽에 값이 다 있는것)
SELECT DISTINCT(e.deptno), d.deptno, d.dname
FROM emp e
RIGHT OUTER JOIN dept d
ON e.deptno = d.deptno;

--ex5) FULL OUTER JOIN
SELECT DISTINCT(e.deptno), d.deptno, d.dname
FROM emp e
FULL OUTER JOIN dept d
ON e.deptno = d.deptno;


--Commit과 Rollback
--DCL(TCL) : 트랜잭션

